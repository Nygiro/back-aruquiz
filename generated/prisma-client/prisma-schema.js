module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateAnswer {
  count: Int!
}

type AggregateMarker {
  count: Int!
}

type AggregateQuestion {
  count: Int!
}

type AggregateQuiz {
  count: Int!
}

type AggregateReport {
  count: Int!
}

type AggregateSchoolClass {
  count: Int!
}

type AggregateSchoolSubject {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Answer {
  id: ID!
  label: String!
  isRight: Boolean!
  question: Question
}

type AnswerConnection {
  pageInfo: PageInfo!
  edges: [AnswerEdge]!
  aggregate: AggregateAnswer!
}

input AnswerCreateInput {
  id: ID
  label: String!
  isRight: Boolean!
  question: QuestionCreateOneInput
}

input AnswerCreateOneInput {
  create: AnswerCreateInput
  connect: AnswerWhereUniqueInput
}

type AnswerEdge {
  node: Answer!
  cursor: String!
}

enum AnswerOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  isRight_ASC
  isRight_DESC
}

type AnswerPreviousValues {
  id: ID!
  label: String!
  isRight: Boolean!
}

type AnswerSubscriptionPayload {
  mutation: MutationType!
  node: Answer
  updatedFields: [String!]
  previousValues: AnswerPreviousValues
}

input AnswerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AnswerWhereInput
  AND: [AnswerSubscriptionWhereInput!]
  OR: [AnswerSubscriptionWhereInput!]
  NOT: [AnswerSubscriptionWhereInput!]
}

input AnswerUpdateDataInput {
  label: String
  isRight: Boolean
  question: QuestionUpdateOneInput
}

input AnswerUpdateInput {
  label: String
  isRight: Boolean
  question: QuestionUpdateOneInput
}

input AnswerUpdateManyMutationInput {
  label: String
  isRight: Boolean
}

input AnswerUpdateOneInput {
  create: AnswerCreateInput
  update: AnswerUpdateDataInput
  upsert: AnswerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: AnswerWhereUniqueInput
}

input AnswerUpsertNestedInput {
  update: AnswerUpdateDataInput!
  create: AnswerCreateInput!
}

input AnswerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  isRight: Boolean
  isRight_not: Boolean
  question: QuestionWhereInput
  AND: [AnswerWhereInput!]
  OR: [AnswerWhereInput!]
  NOT: [AnswerWhereInput!]
}

input AnswerWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Marker {
  id: ID!
  markerId: Int
  imageLink: String
}

type MarkerConnection {
  pageInfo: PageInfo!
  edges: [MarkerEdge]!
  aggregate: AggregateMarker!
}

input MarkerCreateInput {
  id: ID
  markerId: Int
  imageLink: String
}

input MarkerCreateOneInput {
  create: MarkerCreateInput
  connect: MarkerWhereUniqueInput
}

type MarkerEdge {
  node: Marker!
  cursor: String!
}

enum MarkerOrderByInput {
  id_ASC
  id_DESC
  markerId_ASC
  markerId_DESC
  imageLink_ASC
  imageLink_DESC
}

type MarkerPreviousValues {
  id: ID!
  markerId: Int
  imageLink: String
}

type MarkerSubscriptionPayload {
  mutation: MutationType!
  node: Marker
  updatedFields: [String!]
  previousValues: MarkerPreviousValues
}

input MarkerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MarkerWhereInput
  AND: [MarkerSubscriptionWhereInput!]
  OR: [MarkerSubscriptionWhereInput!]
  NOT: [MarkerSubscriptionWhereInput!]
}

input MarkerUpdateDataInput {
  markerId: Int
  imageLink: String
}

input MarkerUpdateInput {
  markerId: Int
  imageLink: String
}

input MarkerUpdateManyMutationInput {
  markerId: Int
  imageLink: String
}

input MarkerUpdateOneInput {
  create: MarkerCreateInput
  update: MarkerUpdateDataInput
  upsert: MarkerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MarkerWhereUniqueInput
}

input MarkerUpsertNestedInput {
  update: MarkerUpdateDataInput!
  create: MarkerCreateInput!
}

input MarkerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  markerId: Int
  markerId_not: Int
  markerId_in: [Int!]
  markerId_not_in: [Int!]
  markerId_lt: Int
  markerId_lte: Int
  markerId_gt: Int
  markerId_gte: Int
  imageLink: String
  imageLink_not: String
  imageLink_in: [String!]
  imageLink_not_in: [String!]
  imageLink_lt: String
  imageLink_lte: String
  imageLink_gt: String
  imageLink_gte: String
  imageLink_contains: String
  imageLink_not_contains: String
  imageLink_starts_with: String
  imageLink_not_starts_with: String
  imageLink_ends_with: String
  imageLink_not_ends_with: String
  AND: [MarkerWhereInput!]
  OR: [MarkerWhereInput!]
  NOT: [MarkerWhereInput!]
}

input MarkerWhereUniqueInput {
  id: ID
}

type Mutation {
  createAnswer(data: AnswerCreateInput!): Answer!
  updateAnswer(data: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer
  updateManyAnswers(data: AnswerUpdateManyMutationInput!, where: AnswerWhereInput): BatchPayload!
  upsertAnswer(where: AnswerWhereUniqueInput!, create: AnswerCreateInput!, update: AnswerUpdateInput!): Answer!
  deleteAnswer(where: AnswerWhereUniqueInput!): Answer
  deleteManyAnswers(where: AnswerWhereInput): BatchPayload!
  createMarker(data: MarkerCreateInput!): Marker!
  updateMarker(data: MarkerUpdateInput!, where: MarkerWhereUniqueInput!): Marker
  updateManyMarkers(data: MarkerUpdateManyMutationInput!, where: MarkerWhereInput): BatchPayload!
  upsertMarker(where: MarkerWhereUniqueInput!, create: MarkerCreateInput!, update: MarkerUpdateInput!): Marker!
  deleteMarker(where: MarkerWhereUniqueInput!): Marker
  deleteManyMarkers(where: MarkerWhereInput): BatchPayload!
  createQuestion(data: QuestionCreateInput!): Question!
  updateQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question
  updateManyQuestions(data: QuestionUpdateManyMutationInput!, where: QuestionWhereInput): BatchPayload!
  upsertQuestion(where: QuestionWhereUniqueInput!, create: QuestionCreateInput!, update: QuestionUpdateInput!): Question!
  deleteQuestion(where: QuestionWhereUniqueInput!): Question
  deleteManyQuestions(where: QuestionWhereInput): BatchPayload!
  createQuiz(data: QuizCreateInput!): Quiz!
  updateQuiz(data: QuizUpdateInput!, where: QuizWhereUniqueInput!): Quiz
  updateManyQuizzes(data: QuizUpdateManyMutationInput!, where: QuizWhereInput): BatchPayload!
  upsertQuiz(where: QuizWhereUniqueInput!, create: QuizCreateInput!, update: QuizUpdateInput!): Quiz!
  deleteQuiz(where: QuizWhereUniqueInput!): Quiz
  deleteManyQuizzes(where: QuizWhereInput): BatchPayload!
  createReport(data: ReportCreateInput!): Report!
  updateReport(data: ReportUpdateInput!, where: ReportWhereUniqueInput!): Report
  upsertReport(where: ReportWhereUniqueInput!, create: ReportCreateInput!, update: ReportUpdateInput!): Report!
  deleteReport(where: ReportWhereUniqueInput!): Report
  deleteManyReports(where: ReportWhereInput): BatchPayload!
  createSchoolClass(data: SchoolClassCreateInput!): SchoolClass!
  updateSchoolClass(data: SchoolClassUpdateInput!, where: SchoolClassWhereUniqueInput!): SchoolClass
  updateManySchoolClasses(data: SchoolClassUpdateManyMutationInput!, where: SchoolClassWhereInput): BatchPayload!
  upsertSchoolClass(where: SchoolClassWhereUniqueInput!, create: SchoolClassCreateInput!, update: SchoolClassUpdateInput!): SchoolClass!
  deleteSchoolClass(where: SchoolClassWhereUniqueInput!): SchoolClass
  deleteManySchoolClasses(where: SchoolClassWhereInput): BatchPayload!
  createSchoolSubject(data: SchoolSubjectCreateInput!): SchoolSubject!
  updateSchoolSubject(data: SchoolSubjectUpdateInput!, where: SchoolSubjectWhereUniqueInput!): SchoolSubject
  updateManySchoolSubjects(data: SchoolSubjectUpdateManyMutationInput!, where: SchoolSubjectWhereInput): BatchPayload!
  upsertSchoolSubject(where: SchoolSubjectWhereUniqueInput!, create: SchoolSubjectCreateInput!, update: SchoolSubjectUpdateInput!): SchoolSubject!
  deleteSchoolSubject(where: SchoolSubjectWhereUniqueInput!): SchoolSubject
  deleteManySchoolSubjects(where: SchoolSubjectWhereInput): BatchPayload!
  createStudent(data: StudentCreateInput!): Student!
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  updateManyStudents(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): BatchPayload!
  upsertStudent(where: StudentWhereUniqueInput!, create: StudentCreateInput!, update: StudentUpdateInput!): Student!
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  answer(where: AnswerWhereUniqueInput!): Answer
  answers(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Answer]!
  answersConnection(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AnswerConnection!
  marker(where: MarkerWhereUniqueInput!): Marker
  markers(where: MarkerWhereInput, orderBy: MarkerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Marker]!
  markersConnection(where: MarkerWhereInput, orderBy: MarkerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MarkerConnection!
  question(where: QuestionWhereUniqueInput!): Question
  questions(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Question]!
  questionsConnection(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuestionConnection!
  quiz(where: QuizWhereUniqueInput!): Quiz
  quizzes(where: QuizWhereInput, orderBy: QuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quiz]!
  quizzesConnection(where: QuizWhereInput, orderBy: QuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuizConnection!
  report(where: ReportWhereUniqueInput!): Report
  reports(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report]!
  reportsConnection(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReportConnection!
  schoolClass(where: SchoolClassWhereUniqueInput!): SchoolClass
  schoolClasses(where: SchoolClassWhereInput, orderBy: SchoolClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SchoolClass]!
  schoolClassesConnection(where: SchoolClassWhereInput, orderBy: SchoolClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SchoolClassConnection!
  schoolSubject(where: SchoolSubjectWhereUniqueInput!): SchoolSubject
  schoolSubjects(where: SchoolSubjectWhereInput, orderBy: SchoolSubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SchoolSubject]!
  schoolSubjectsConnection(where: SchoolSubjectWhereInput, orderBy: SchoolSubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SchoolSubjectConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student]!
  studentsConnection(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudentConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Question {
  id: ID!
  label: String!
  quiz: Quiz
}

type QuestionConnection {
  pageInfo: PageInfo!
  edges: [QuestionEdge]!
  aggregate: AggregateQuestion!
}

input QuestionCreateInput {
  id: ID
  label: String!
  quiz: QuizCreateOneInput
}

input QuestionCreateOneInput {
  create: QuestionCreateInput
  connect: QuestionWhereUniqueInput
}

type QuestionEdge {
  node: Question!
  cursor: String!
}

enum QuestionOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
}

type QuestionPreviousValues {
  id: ID!
  label: String!
}

type QuestionSubscriptionPayload {
  mutation: MutationType!
  node: Question
  updatedFields: [String!]
  previousValues: QuestionPreviousValues
}

input QuestionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionWhereInput
  AND: [QuestionSubscriptionWhereInput!]
  OR: [QuestionSubscriptionWhereInput!]
  NOT: [QuestionSubscriptionWhereInput!]
}

input QuestionUpdateDataInput {
  label: String
  quiz: QuizUpdateOneInput
}

input QuestionUpdateInput {
  label: String
  quiz: QuizUpdateOneInput
}

input QuestionUpdateManyMutationInput {
  label: String
}

input QuestionUpdateOneInput {
  create: QuestionCreateInput
  update: QuestionUpdateDataInput
  upsert: QuestionUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: QuestionWhereUniqueInput
}

input QuestionUpsertNestedInput {
  update: QuestionUpdateDataInput!
  create: QuestionCreateInput!
}

input QuestionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  quiz: QuizWhereInput
  AND: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  NOT: [QuestionWhereInput!]
}

input QuestionWhereUniqueInput {
  id: ID
}

type Quiz {
  id: ID!
  name: String!
  schoolSubject: SchoolSubject
  createdBy: User
}

type QuizConnection {
  pageInfo: PageInfo!
  edges: [QuizEdge]!
  aggregate: AggregateQuiz!
}

input QuizCreateInput {
  id: ID
  name: String!
  schoolSubject: SchoolSubjectCreateOneInput
  createdBy: UserCreateOneWithoutQuizzesInput
}

input QuizCreateManyWithoutCreatedByInput {
  create: [QuizCreateWithoutCreatedByInput!]
  connect: [QuizWhereUniqueInput!]
}

input QuizCreateOneInput {
  create: QuizCreateInput
  connect: QuizWhereUniqueInput
}

input QuizCreateWithoutCreatedByInput {
  id: ID
  name: String!
  schoolSubject: SchoolSubjectCreateOneInput
}

type QuizEdge {
  node: Quiz!
  cursor: String!
}

enum QuizOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type QuizPreviousValues {
  id: ID!
  name: String!
}

input QuizScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [QuizScalarWhereInput!]
  OR: [QuizScalarWhereInput!]
  NOT: [QuizScalarWhereInput!]
}

type QuizSubscriptionPayload {
  mutation: MutationType!
  node: Quiz
  updatedFields: [String!]
  previousValues: QuizPreviousValues
}

input QuizSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuizWhereInput
  AND: [QuizSubscriptionWhereInput!]
  OR: [QuizSubscriptionWhereInput!]
  NOT: [QuizSubscriptionWhereInput!]
}

input QuizUpdateDataInput {
  name: String
  schoolSubject: SchoolSubjectUpdateOneInput
  createdBy: UserUpdateOneWithoutQuizzesInput
}

input QuizUpdateInput {
  name: String
  schoolSubject: SchoolSubjectUpdateOneInput
  createdBy: UserUpdateOneWithoutQuizzesInput
}

input QuizUpdateManyDataInput {
  name: String
}

input QuizUpdateManyMutationInput {
  name: String
}

input QuizUpdateManyWithoutCreatedByInput {
  create: [QuizCreateWithoutCreatedByInput!]
  delete: [QuizWhereUniqueInput!]
  connect: [QuizWhereUniqueInput!]
  set: [QuizWhereUniqueInput!]
  disconnect: [QuizWhereUniqueInput!]
  update: [QuizUpdateWithWhereUniqueWithoutCreatedByInput!]
  upsert: [QuizUpsertWithWhereUniqueWithoutCreatedByInput!]
  deleteMany: [QuizScalarWhereInput!]
  updateMany: [QuizUpdateManyWithWhereNestedInput!]
}

input QuizUpdateManyWithWhereNestedInput {
  where: QuizScalarWhereInput!
  data: QuizUpdateManyDataInput!
}

input QuizUpdateOneInput {
  create: QuizCreateInput
  update: QuizUpdateDataInput
  upsert: QuizUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: QuizWhereUniqueInput
}

input QuizUpdateWithoutCreatedByDataInput {
  name: String
  schoolSubject: SchoolSubjectUpdateOneInput
}

input QuizUpdateWithWhereUniqueWithoutCreatedByInput {
  where: QuizWhereUniqueInput!
  data: QuizUpdateWithoutCreatedByDataInput!
}

input QuizUpsertNestedInput {
  update: QuizUpdateDataInput!
  create: QuizCreateInput!
}

input QuizUpsertWithWhereUniqueWithoutCreatedByInput {
  where: QuizWhereUniqueInput!
  update: QuizUpdateWithoutCreatedByDataInput!
  create: QuizCreateWithoutCreatedByInput!
}

input QuizWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  schoolSubject: SchoolSubjectWhereInput
  createdBy: UserWhereInput
  AND: [QuizWhereInput!]
  OR: [QuizWhereInput!]
  NOT: [QuizWhereInput!]
}

input QuizWhereUniqueInput {
  id: ID
}

type Report {
  id: ID!
  schoolClass: SchoolClass
  student: Student
  quiz: Quiz
  question: Question
  answer: Answer
  createdAt: DateTime!
}

type ReportConnection {
  pageInfo: PageInfo!
  edges: [ReportEdge]!
  aggregate: AggregateReport!
}

input ReportCreateInput {
  id: ID
  schoolClass: SchoolClassCreateOneInput
  student: StudentCreateOneInput
  quiz: QuizCreateOneInput
  question: QuestionCreateOneInput
  answer: AnswerCreateOneInput
}

type ReportEdge {
  node: Report!
  cursor: String!
}

enum ReportOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
}

type ReportPreviousValues {
  id: ID!
  createdAt: DateTime!
}

type ReportSubscriptionPayload {
  mutation: MutationType!
  node: Report
  updatedFields: [String!]
  previousValues: ReportPreviousValues
}

input ReportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReportWhereInput
  AND: [ReportSubscriptionWhereInput!]
  OR: [ReportSubscriptionWhereInput!]
  NOT: [ReportSubscriptionWhereInput!]
}

input ReportUpdateInput {
  schoolClass: SchoolClassUpdateOneInput
  student: StudentUpdateOneInput
  quiz: QuizUpdateOneInput
  question: QuestionUpdateOneInput
  answer: AnswerUpdateOneInput
}

input ReportWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  schoolClass: SchoolClassWhereInput
  student: StudentWhereInput
  quiz: QuizWhereInput
  question: QuestionWhereInput
  answer: AnswerWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ReportWhereInput!]
  OR: [ReportWhereInput!]
  NOT: [ReportWhereInput!]
}

input ReportWhereUniqueInput {
  id: ID
}

type SchoolClass {
  id: ID!
  name: String!
  teacher: User
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student!]
}

type SchoolClassConnection {
  pageInfo: PageInfo!
  edges: [SchoolClassEdge]!
  aggregate: AggregateSchoolClass!
}

input SchoolClassCreateInput {
  id: ID
  name: String!
  teacher: UserCreateOneWithoutSchoolClassInput
  students: StudentCreateManyWithoutSchoolClassInput
}

input SchoolClassCreateManyWithoutTeacherInput {
  create: [SchoolClassCreateWithoutTeacherInput!]
  connect: [SchoolClassWhereUniqueInput!]
}

input SchoolClassCreateOneInput {
  create: SchoolClassCreateInput
  connect: SchoolClassWhereUniqueInput
}

input SchoolClassCreateOneWithoutStudentsInput {
  create: SchoolClassCreateWithoutStudentsInput
  connect: SchoolClassWhereUniqueInput
}

input SchoolClassCreateWithoutStudentsInput {
  id: ID
  name: String!
  teacher: UserCreateOneWithoutSchoolClassInput
}

input SchoolClassCreateWithoutTeacherInput {
  id: ID
  name: String!
  students: StudentCreateManyWithoutSchoolClassInput
}

type SchoolClassEdge {
  node: SchoolClass!
  cursor: String!
}

enum SchoolClassOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type SchoolClassPreviousValues {
  id: ID!
  name: String!
}

input SchoolClassScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SchoolClassScalarWhereInput!]
  OR: [SchoolClassScalarWhereInput!]
  NOT: [SchoolClassScalarWhereInput!]
}

type SchoolClassSubscriptionPayload {
  mutation: MutationType!
  node: SchoolClass
  updatedFields: [String!]
  previousValues: SchoolClassPreviousValues
}

input SchoolClassSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SchoolClassWhereInput
  AND: [SchoolClassSubscriptionWhereInput!]
  OR: [SchoolClassSubscriptionWhereInput!]
  NOT: [SchoolClassSubscriptionWhereInput!]
}

input SchoolClassUpdateDataInput {
  name: String
  teacher: UserUpdateOneWithoutSchoolClassInput
  students: StudentUpdateManyWithoutSchoolClassInput
}

input SchoolClassUpdateInput {
  name: String
  teacher: UserUpdateOneWithoutSchoolClassInput
  students: StudentUpdateManyWithoutSchoolClassInput
}

input SchoolClassUpdateManyDataInput {
  name: String
}

input SchoolClassUpdateManyMutationInput {
  name: String
}

input SchoolClassUpdateManyWithoutTeacherInput {
  create: [SchoolClassCreateWithoutTeacherInput!]
  delete: [SchoolClassWhereUniqueInput!]
  connect: [SchoolClassWhereUniqueInput!]
  set: [SchoolClassWhereUniqueInput!]
  disconnect: [SchoolClassWhereUniqueInput!]
  update: [SchoolClassUpdateWithWhereUniqueWithoutTeacherInput!]
  upsert: [SchoolClassUpsertWithWhereUniqueWithoutTeacherInput!]
  deleteMany: [SchoolClassScalarWhereInput!]
  updateMany: [SchoolClassUpdateManyWithWhereNestedInput!]
}

input SchoolClassUpdateManyWithWhereNestedInput {
  where: SchoolClassScalarWhereInput!
  data: SchoolClassUpdateManyDataInput!
}

input SchoolClassUpdateOneInput {
  create: SchoolClassCreateInput
  update: SchoolClassUpdateDataInput
  upsert: SchoolClassUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SchoolClassWhereUniqueInput
}

input SchoolClassUpdateOneWithoutStudentsInput {
  create: SchoolClassCreateWithoutStudentsInput
  update: SchoolClassUpdateWithoutStudentsDataInput
  upsert: SchoolClassUpsertWithoutStudentsInput
  delete: Boolean
  disconnect: Boolean
  connect: SchoolClassWhereUniqueInput
}

input SchoolClassUpdateWithoutStudentsDataInput {
  name: String
  teacher: UserUpdateOneWithoutSchoolClassInput
}

input SchoolClassUpdateWithoutTeacherDataInput {
  name: String
  students: StudentUpdateManyWithoutSchoolClassInput
}

input SchoolClassUpdateWithWhereUniqueWithoutTeacherInput {
  where: SchoolClassWhereUniqueInput!
  data: SchoolClassUpdateWithoutTeacherDataInput!
}

input SchoolClassUpsertNestedInput {
  update: SchoolClassUpdateDataInput!
  create: SchoolClassCreateInput!
}

input SchoolClassUpsertWithoutStudentsInput {
  update: SchoolClassUpdateWithoutStudentsDataInput!
  create: SchoolClassCreateWithoutStudentsInput!
}

input SchoolClassUpsertWithWhereUniqueWithoutTeacherInput {
  where: SchoolClassWhereUniqueInput!
  update: SchoolClassUpdateWithoutTeacherDataInput!
  create: SchoolClassCreateWithoutTeacherInput!
}

input SchoolClassWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  teacher: UserWhereInput
  students_every: StudentWhereInput
  students_some: StudentWhereInput
  students_none: StudentWhereInput
  AND: [SchoolClassWhereInput!]
  OR: [SchoolClassWhereInput!]
  NOT: [SchoolClassWhereInput!]
}

input SchoolClassWhereUniqueInput {
  id: ID
}

type SchoolSubject {
  id: ID!
  name: String!
}

type SchoolSubjectConnection {
  pageInfo: PageInfo!
  edges: [SchoolSubjectEdge]!
  aggregate: AggregateSchoolSubject!
}

input SchoolSubjectCreateInput {
  id: ID
  name: String!
}

input SchoolSubjectCreateOneInput {
  create: SchoolSubjectCreateInput
  connect: SchoolSubjectWhereUniqueInput
}

type SchoolSubjectEdge {
  node: SchoolSubject!
  cursor: String!
}

enum SchoolSubjectOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type SchoolSubjectPreviousValues {
  id: ID!
  name: String!
}

type SchoolSubjectSubscriptionPayload {
  mutation: MutationType!
  node: SchoolSubject
  updatedFields: [String!]
  previousValues: SchoolSubjectPreviousValues
}

input SchoolSubjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SchoolSubjectWhereInput
  AND: [SchoolSubjectSubscriptionWhereInput!]
  OR: [SchoolSubjectSubscriptionWhereInput!]
  NOT: [SchoolSubjectSubscriptionWhereInput!]
}

input SchoolSubjectUpdateDataInput {
  name: String
}

input SchoolSubjectUpdateInput {
  name: String
}

input SchoolSubjectUpdateManyMutationInput {
  name: String
}

input SchoolSubjectUpdateOneInput {
  create: SchoolSubjectCreateInput
  update: SchoolSubjectUpdateDataInput
  upsert: SchoolSubjectUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SchoolSubjectWhereUniqueInput
}

input SchoolSubjectUpsertNestedInput {
  update: SchoolSubjectUpdateDataInput!
  create: SchoolSubjectCreateInput!
}

input SchoolSubjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SchoolSubjectWhereInput!]
  OR: [SchoolSubjectWhereInput!]
  NOT: [SchoolSubjectWhereInput!]
}

input SchoolSubjectWhereUniqueInput {
  id: ID
}

type Student {
  id: ID!
  firstName: String!
  lastName: String!
  schoolClass: SchoolClass
  marker: Marker
}

type StudentConnection {
  pageInfo: PageInfo!
  edges: [StudentEdge]!
  aggregate: AggregateStudent!
}

input StudentCreateInput {
  id: ID
  firstName: String!
  lastName: String!
  schoolClass: SchoolClassCreateOneWithoutStudentsInput
  marker: MarkerCreateOneInput
}

input StudentCreateManyWithoutSchoolClassInput {
  create: [StudentCreateWithoutSchoolClassInput!]
  connect: [StudentWhereUniqueInput!]
}

input StudentCreateOneInput {
  create: StudentCreateInput
  connect: StudentWhereUniqueInput
}

input StudentCreateWithoutSchoolClassInput {
  id: ID
  firstName: String!
  lastName: String!
  marker: MarkerCreateOneInput
}

type StudentEdge {
  node: Student!
  cursor: String!
}

enum StudentOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
}

type StudentPreviousValues {
  id: ID!
  firstName: String!
  lastName: String!
}

input StudentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  AND: [StudentScalarWhereInput!]
  OR: [StudentScalarWhereInput!]
  NOT: [StudentScalarWhereInput!]
}

type StudentSubscriptionPayload {
  mutation: MutationType!
  node: Student
  updatedFields: [String!]
  previousValues: StudentPreviousValues
}

input StudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudentWhereInput
  AND: [StudentSubscriptionWhereInput!]
  OR: [StudentSubscriptionWhereInput!]
  NOT: [StudentSubscriptionWhereInput!]
}

input StudentUpdateDataInput {
  firstName: String
  lastName: String
  schoolClass: SchoolClassUpdateOneWithoutStudentsInput
  marker: MarkerUpdateOneInput
}

input StudentUpdateInput {
  firstName: String
  lastName: String
  schoolClass: SchoolClassUpdateOneWithoutStudentsInput
  marker: MarkerUpdateOneInput
}

input StudentUpdateManyDataInput {
  firstName: String
  lastName: String
}

input StudentUpdateManyMutationInput {
  firstName: String
  lastName: String
}

input StudentUpdateManyWithoutSchoolClassInput {
  create: [StudentCreateWithoutSchoolClassInput!]
  delete: [StudentWhereUniqueInput!]
  connect: [StudentWhereUniqueInput!]
  set: [StudentWhereUniqueInput!]
  disconnect: [StudentWhereUniqueInput!]
  update: [StudentUpdateWithWhereUniqueWithoutSchoolClassInput!]
  upsert: [StudentUpsertWithWhereUniqueWithoutSchoolClassInput!]
  deleteMany: [StudentScalarWhereInput!]
  updateMany: [StudentUpdateManyWithWhereNestedInput!]
}

input StudentUpdateManyWithWhereNestedInput {
  where: StudentScalarWhereInput!
  data: StudentUpdateManyDataInput!
}

input StudentUpdateOneInput {
  create: StudentCreateInput
  update: StudentUpdateDataInput
  upsert: StudentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: StudentWhereUniqueInput
}

input StudentUpdateWithoutSchoolClassDataInput {
  firstName: String
  lastName: String
  marker: MarkerUpdateOneInput
}

input StudentUpdateWithWhereUniqueWithoutSchoolClassInput {
  where: StudentWhereUniqueInput!
  data: StudentUpdateWithoutSchoolClassDataInput!
}

input StudentUpsertNestedInput {
  update: StudentUpdateDataInput!
  create: StudentCreateInput!
}

input StudentUpsertWithWhereUniqueWithoutSchoolClassInput {
  where: StudentWhereUniqueInput!
  update: StudentUpdateWithoutSchoolClassDataInput!
  create: StudentCreateWithoutSchoolClassInput!
}

input StudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  schoolClass: SchoolClassWhereInput
  marker: MarkerWhereInput
  AND: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
}

input StudentWhereUniqueInput {
  id: ID
}

type Subscription {
  answer(where: AnswerSubscriptionWhereInput): AnswerSubscriptionPayload
  marker(where: MarkerSubscriptionWhereInput): MarkerSubscriptionPayload
  question(where: QuestionSubscriptionWhereInput): QuestionSubscriptionPayload
  quiz(where: QuizSubscriptionWhereInput): QuizSubscriptionPayload
  report(where: ReportSubscriptionWhereInput): ReportSubscriptionPayload
  schoolClass(where: SchoolClassSubscriptionWhereInput): SchoolClassSubscriptionPayload
  schoolSubject(where: SchoolSubjectSubscriptionWhereInput): SchoolSubjectSubscriptionPayload
  student(where: StudentSubscriptionWhereInput): StudentSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String
  name: String!
  password: String!
  schoolClass(where: SchoolClassWhereInput, orderBy: SchoolClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SchoolClass!]
  quizzes(where: QuizWhereInput, orderBy: QuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quiz!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String
  name: String!
  password: String!
  schoolClass: SchoolClassCreateManyWithoutTeacherInput
  quizzes: QuizCreateManyWithoutCreatedByInput
}

input UserCreateOneWithoutQuizzesInput {
  create: UserCreateWithoutQuizzesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutSchoolClassInput {
  create: UserCreateWithoutSchoolClassInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutQuizzesInput {
  id: ID
  email: String
  name: String!
  password: String!
  schoolClass: SchoolClassCreateManyWithoutTeacherInput
}

input UserCreateWithoutSchoolClassInput {
  id: ID
  email: String
  name: String!
  password: String!
  quizzes: QuizCreateManyWithoutCreatedByInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  email: String
  name: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  name: String
  password: String
  schoolClass: SchoolClassUpdateManyWithoutTeacherInput
  quizzes: QuizUpdateManyWithoutCreatedByInput
}

input UserUpdateManyMutationInput {
  email: String
  name: String
  password: String
}

input UserUpdateOneWithoutQuizzesInput {
  create: UserCreateWithoutQuizzesInput
  update: UserUpdateWithoutQuizzesDataInput
  upsert: UserUpsertWithoutQuizzesInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutSchoolClassInput {
  create: UserCreateWithoutSchoolClassInput
  update: UserUpdateWithoutSchoolClassDataInput
  upsert: UserUpsertWithoutSchoolClassInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutQuizzesDataInput {
  email: String
  name: String
  password: String
  schoolClass: SchoolClassUpdateManyWithoutTeacherInput
}

input UserUpdateWithoutSchoolClassDataInput {
  email: String
  name: String
  password: String
  quizzes: QuizUpdateManyWithoutCreatedByInput
}

input UserUpsertWithoutQuizzesInput {
  update: UserUpdateWithoutQuizzesDataInput!
  create: UserCreateWithoutQuizzesInput!
}

input UserUpsertWithoutSchoolClassInput {
  update: UserUpdateWithoutSchoolClassDataInput!
  create: UserCreateWithoutSchoolClassInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  schoolClass_every: SchoolClassWhereInput
  schoolClass_some: SchoolClassWhereInput
  schoolClass_none: SchoolClassWhereInput
  quizzes_every: QuizWhereInput
  quizzes_some: QuizWhereInput
  quizzes_none: QuizWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    